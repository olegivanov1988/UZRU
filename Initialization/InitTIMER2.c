#include "MDR1986VE1T.h"

void InitTIMER2 () {
  
  MDR_TIMER2->CNT = 0;

  MDR_TIMER2->PSG = 0;    // Значение предварительного делителя счётчика. Основной счётчик считает на частоте CLK = TIM_CLK/(PSG+1)
  
  MDR_TIMER2->ARR = 0xFFFFFFFF;

  MDR_TIMER2->CNTRL = 
  ( 0 << 8 ) |  // EVENT_SEL - Биты выбора источника событий для счёта ( 0000 - передний фронт TIM_CLK, 0001 - CNT==ARR в таймере 1, 0010 - CNT==ARR в таймере 2, 0011 - CNT==ARR в таймере 3, 0100 - событие на первом канале, ..., 1000 - событие переднего фронта ETR, 1001 - событие заднего фронта ETR, 1010 - CNT==ARR в таймере 4 )
  ( 0 << 6 ) |  // CNT_MODE - Режим счёта основного счётчика ( 00 - счётчик вверх при DIR==0 и счётчик вниз при DIR==1 при PSG==0, 01 - счётчик вверх/вниз с автоматическим изменением DIR при CNT==0 или CNT==ARR, 1x - счётчик вверх при DIR==0 и счётчик вниз при DIR==1 при EVENT==1 )
  ( 0 << 4 ) |  // FDTS - Частота семплирования данных FDTS ( 00 - каждый TIM_CLK, 01 - каждый второй TIM_CLK, 10 - каждый третий TIM_CLK, 11 - каждый четвёртый TIM_CLK )
  ( 0 << 3 ) |  // DIR - Направление счёта основного счётчика ( 0 - вверх, от 0 до ARR, 1 - вниз, от ARR до 0 )
  ( 0 << 2 ) |  // WR_CMPL - Окончание записи при задании нового значения регистров CNT, PSG и ARR ( 0 - новые данные можно записывать, 1 - данные не записаны и идёт запись )
  ( 0 << 1 ) |  // ARRB_EN - Разрешение мгновенного обновления ARR ( 0 - ARR будет перезаписан в момент записи в ARR, 1 - ARR будет перезаписан при завершении счёта CNT )
  ( 1 << 0 );    // CNT_EN - Разрешение работы таймера ( 0 - таймер отключен, 1 - таймер включен )

  MDR_TIMER2->CCR1 = 0; // CCR - Значение CCR, с которым сравнивается CNT при работе в ШИМ-режиме. Значение CNT, при котором произошёл факт захвата события в режиме захвата.
  
  MDR_TIMER2->CCR11 = 0; // CCR1 - Значение, с которым сравнивается CNT при работе в ШИМ-режиме. Значение CNT, при котором произошёл факт захвата события в режиме захвата.
  
  MDR_TIMER2->CH1_CNTRL =
  ( 0 << 15 ) | // CAP_nPWM - Режим работы канала Захват или ШИМ ( 0 - канал работает в режиме ШИМ, 1 - канал работает в режиме Захват )
  ( 0 << 14 ) | // WR_CMPL - Флаг окончания записи, при задании нового значения регистра CCR ( 0 - новые данные можно записывать, 1 - данные не записаны и идёт запись )
  ( 0 << 13 ) | // ETREN - Разрешение сброса по выводу ETR ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 12 ) | // BRKEN - Разрешение сброса по выводу BRK ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 9 )  | // OCCM - Формат выработки сигнала REF в режиме ШИМ ( см. техническое описание )
  ( 0 << 8 )  | // OCCE - Разрешение работы ETR ( 0 - запрет ETR, 1 - разрешение ETR )
  ( 0 << 6 )  | // CHPSC - Предварителеьный делитель входного канала ( 0 - нет деления, 1 - деление на 2, 2 - деление на 4, 3 - деление на 8 )
  ( 0 << 4 )  | // CHSEL - Выбор события по входному каналу CH1 для фиксации значения основного счётчика ( см. техническое описание)
  ( 0 << 0 );   // CHFLTR - В скольки триггерах должен быть зафиксирован сигнал (см. техническое описание)

  MDR_TIMER2->CH1_CNTRL1 = 
  ( 0 << 12 ) | // NINV - Режим выходной инверсии инверсного канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 10 ) | // NSELO - Режим работы выхода инверсного канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 8 )  | // NSELOE - Режим работы инверсного канала на выход ( 00 - всегда на OE выдаётся 0, канал на выход не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход, 11 - на OE выдаётся сигнал с DTG, при CHn==0 вход, при CHn==1 выход )
  ( 0 << 4 )  | // INV - Режим выходной инверсии прямого канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 2 )  | // SELO - Режим работы выхода прямого канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 0 )  ; // SELOE - Режим работы прямого канала на выход ( 00 - всегда на OE выдаётся 0, канал на выходе не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход. 11 - на OE выдаётся сигнал DTG, при CH==0 вход, при CH==1 выход )

  MDR_TIMER2->CH1_CNTRL2 =
  ( 0 << 3 ) | // CRRRLD - Разрешение обновления регистров CCR и CCR1 ( 0 - обновление возможно в любой момент времени, 1 - обновление будет осуществлено только при CNT=0 )
  ( 0 << 2 ) | // CCR1_EN - Разрешение работы регистра CCR1 ( 0 - CCR1 не используется, 1 - CCR1 используется )
  ( 0 << 0 ) ; // CHSEL1 - Выбор события по входному каналу для CAP1 ( 00 - положительный фронт по Chi, 01 - отрицательный фронт по Chi, 10 - отрицательный фронт от канала Ch(i+1), 11 - отрицательный фронт от канала Ch(i+2) )

  MDR_TIMER2->CH1_DTG = 
  ( 0 << 8 ) | // DTGx - Основной делитель частоты ( от 0 до 256, задержка DTGdel==DTGx*(DTG+1) )
  ( 0 << 4 )  | // EDTS - Выбор источника тактовой частоты для DTG ( 0 - TIM_CLK, 1 - FDTS )
  ( 0 << 0 )  ; // DTG - Предварительный делитель частоты

  MDR_TIMER2->CH2_CNTRL =
  ( 1 << 15 ) | // CAP_nPWM - Ржим работы канала Захват или ШИМ ( 0 - канал работает в режиме ШИМ, 1 - канал работает в режиме Захват )
  ( 0 << 14 ) | // WR_CMPL - Флаг окончания записи, при задании нового значения регистра CCR ( 0 - новые данные можно записывать, 1 - данные не записаны и идёт запись )
  ( 0 << 13 ) | // ETREN - Разрешение сброса по выводу ETR ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 12 ) | // BRKEN - Разрешение сброса по выводу BRK ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 9 )  | // OCCM - Формат выработки сигнала REF в режиме ШИМ ( см. техническое описание )
  ( 0 << 8 )  | // OCCE - Разрешение работы ETR ( 0 - запрет ETR, 1 - разрешение ETR )
  ( 0 << 6 )  | // CHPSC - Предварителеьный делитель входного канала ( 0 - нет деления, 1 - деление на 2, 2 - деление на 4, 3 - деление на 8 )
  ( 0 << 4 )  | // CHSEL - Выбор события по входному каналу CH2 для фиксации значения основного счётчика ( см. техническое описание)
  ( 0 << 0 );   // CHFLTR - В скольки триггерах должен быть зафиксирован сигнал (см. техническое описание)

  MDR_TIMER2->CH2_CNTRL1 = 
  ( 0 << 12 ) | // NINV - Режим выходной инверсии инверсного канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 10 ) | // NSELO - Режим работы выхода инверсного канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 8 )  | // NSELOE - Режим работы инверсного канала на выход ( 00 - всегда на OE выдаётся 0, канал на выход не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход, 11 - на OE выдаётся сигнал с DTG, при CHn==0 вход, при CHn==1 выход )
  ( 0 << 4 )  | // INV - Режим выходной инверсии прямого канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 2 )  | // SELO - Режим работы выхода прямого канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 0 )  ; // SELOE - Режим работы прямого канала на выход ( 00 - всегда на OE выдаётся 0, канал на выходе не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход. 11 - на OE выдаётся сигнал DTG, при CH==0 вход, при CH==1 выход )

  MDR_TIMER2->CH2_CNTRL2 =
  ( 0 << 3 ) | // CRRRLD - Разрешение обновления регистров CCR и CCR1 ( 0 - обновление возможно в любой момент времени, 1 - обновление будет осуществлено только при CNT=0 )
  ( 0 << 2 ) | // CCR1_EN - Разрешение работы регистра CCR1 ( 0 - CCR1 не используется, 1 - CCR1 используется )
  ( 0 << 0 ) ; // CHSEL1 - Выбор события по входному каналу для CAP1 ( 00 - положительный фронт по Chi, 01 - отрицательный фронт по Chi, 10 - отрицательный фронт от канала Ch(i+1), 11 - отрицательный фронт от канала Ch(i+2) )

  MDR_TIMER2->CH2_DTG = 
  ( 0 << 8 ) | // DTGx - Основной делитель частоты ( от 0 до 256, задержка DTGdel==DTGx*(DTG+1) )
  ( 0 << 4 )  | // EDTS - Выбор источника тактовой частоты для DTG ( 0 - TIM_CLK, 1 - FDTS )
  ( 0 << 0 )  ; // DTG - Предварительный делитель частоты

  MDR_TIMER2->CH3_CNTRL =
  ( 0 << 15 ) | // CAP_nPWM - Ржим работы канала Захват или ШИМ ( 0 - канал работает в режиме ШИМ, 1 - канал работает в режиме Захват )
  ( 0 << 14 ) | // WR_CMPL - Флаг окончания записи, при задании нового значения регистра CCR ( 0 - новые данные можно записывать, 1 - данные не записаны и идёт запись )
  ( 0 << 13 ) | // ETREN - Разрешение сброса по выводу ETR ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 12 ) | // BRKEN - Разрешение сброса по выводу BRK ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 9 )  | // OCCM - Формат выработки сигнала REF в режиме ШИМ ( см. техническое описание )
  ( 0 << 8 )  | // OCCE - Разрешение работы ETR ( 0 - запрет ETR, 1 - разрешение ETR )
  ( 0 << 6 )  | // CHPSC - Предварителеьный делитель входного канала ( 0 - нет деления, 1 - деление на 2, 2 - деление на 4, 3 - деление на 8 )
  ( 0 << 4 )  | // CHSEL - Выбор события по входному каналу CH3 для фиксации значения основного счётчика ( см. техническое описание)
  ( 0 << 0 );   // CHFLTR - В скольки триггерах должен быть зафиксирован сигнал (см. техническое описание)

  MDR_TIMER2->CH3_CNTRL1 = 
  ( 0 << 12 ) | // NINV - Режим выходной инверсии инверсного канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 10 ) | // NSELO - Режим работы выхода инверсного канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 8 )  | // NSELOE - Режим работы инверсного канала на выход ( 00 - всегда на OE выдаётся 0, канал на выход не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход, 11 - на OE выдаётся сигнал с DTG, при CHn==0 вход, при CHn==1 выход )
  ( 0 << 4 )  | // INV - Режим выходной инверсии прямого канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 2 )  | // SELO - Режим работы выхода прямого канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 0 )  ; // SELOE - Режим работы прямого канала на выход ( 00 - всегда на OE выдаётся 0, канал на выходе не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход. 11 - на OE выдаётся сигнал DTG, при CH==0 вход, при CH==1 выход )

  MDR_TIMER2->CH3_CNTRL2 =
  ( 0 << 3 ) | // CRRRLD - Разрешение обновления регистров CCR и CCR1 ( 0 - обновление возможно в любой момент времени, 1 - обновление будет осуществлено только при CNT=0 )
  ( 0 << 2 ) | // CCR1_EN - Разрешение работы регистра CCR1 ( 0 - CCR1 не используется, 1 - CCR1 используется )
  ( 0 << 0 ) ; // CHSEL1 - Выбор события по входному каналу для CAP1 ( 00 - положительный фронт по Chi, 01 - отрицательный фронт по Chi, 10 - отрицательный фронт от канала Ch(i+1), 11 - отрицательный фронт от канала Ch(i+2) )

  MDR_TIMER2->CH3_DTG = 
  ( 0 << 8 ) | // DTGx - Основной делитель частоты ( от 0 до 256, задержка DTGdel==DTGx*(DTG+1) )
  ( 0 << 4 ) | // EDTS - Выбор источника тактовой частоты для DTG ( 0 - TIM_CLK, 1 - FDTS )
  ( 0 << 0 ) ; // DTG - Предварительный делитель частоты

  MDR_TIMER2->CH4_CNTRL =
  ( 0 << 15 ) | // CAP_nPWM - Ржим работы канала Захват или ШИМ ( 0 - канал работает в режиме ШИМ, 1 - канал работает в режиме Захват )
  ( 0 << 14 ) | // WR_CMPL - Флаг окончания записи, при задании нового значения регистра CCR ( 0 - новые данные можно записывать, 1 - данные не записаны и идёт запись )
  ( 0 << 13 ) | // ETREN - Разрешение сброса по выводу ETR ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 12 ) | // BRKEN - Разрешение сброса по выводу BRK ( 0 - запрещен сброс, 1 - разрешен сброс )
  ( 0 << 9 )  | // OCCM - Формат выработки сигнала REF в режиме ШИМ ( см. техническое описание )
  ( 0 << 8 )  | // OCCE - Разрешение работы ETR ( 0 - запрет ETR, 1 - разрешение ETR )
  ( 0 << 6 )  | // CHPSC - Предварителеьный делитель входного канала ( 0 - нет деления, 1 - деление на 2, 2 - деление на 4, 3 - деление на 8 )
  ( 0 << 4 )  | // CHSEL - Выбор события по входному каналу CH4 для фиксации значения основного счётчика ( см. техническое описание)
  ( 0 << 0 );   // CHFLTR - В скольки триггерах должен быть зафиксирован сигнал (см. техническое описание)

  MDR_TIMER2->CH4_CNTRL1 = 
  ( 0 << 12 ) | // NINV - Режим выходной инверсии инверсного канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 10 ) | // NSELO - Режим работы выхода инверсного канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 8 )  | // NSELOE - Режим работы инверсного канала на выход ( 00 - всегда на OE выдаётся 0, канал на выход не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход, 11 - на OE выдаётся сигнал с DTG, при CHn==0 вход, при CHn==1 выход )
  ( 0 << 4 )  | // INV - Режим выходной инверсии прямого канала ( 0 - выход не инвертируется, 1 - выход инвертируется )
  ( 0 << 2 )  | // SELO - Режим работы выхода прямого канала ( 00 - всегда на выход выдаётся 0, канал на выходе не работает, 01 - всегда на выход выдаётся 1, канал всегда работает на выход, 10 - на выход выдаётся сигнал REF, 11 - на выход выдаётся сигнал DTG )
  ( 0 << 0 )  ; // SELOE - Режим работы прямого канала на выход ( 00 - всегда на OE выдаётся 0, канал на выходе не работает, 01 - всегда на OE выдаётся 1, канал всегда работает на выход, 10 - на OE выдаётся сигнал REF, при REF==0 вход, при REF==1 выход. 11 - на OE выдаётся сигнал DTG, при CH==0 вход, при CH==1 выход )

  MDR_TIMER2->CH4_CNTRL2 =
  ( 0 << 3 ) | // CRRRLD - Разрешение обновления регистров CCR и CCR1 ( 0 - обновление возможно в любой момент времени, 1 - обновление будет осуществлено только при CNT=0 )
  ( 0 << 2 ) | // CCR1_EN - Разрешение работы регистра CCR1 ( 0 - CCR1 не используется, 1 - CCR1 используется )
  ( 0 << 0 ) ; // CHSEL1 - Выбор события по входному каналу для CAP1 ( 00 - положительный фронт по Chi, 01 - отрицательный фронт по Chi, 10 - отрицательный фронт от канала Ch(i+1), 11 - отрицательный фронт от канала Ch(i+2) )

  MDR_TIMER2->CH4_DTG = 
  ( 0 << 8 ) | // DTGx - Основной делитель частоты ( от 0 до 256, задержка DTGdel==DTGx*(DTG+1) )
  ( 0 << 4 )  | // EDTS - Выбор источника тактовой частоты для DTG ( 0 - TIM_CLK, 1 - FDTS )
  ( 0 << 0 )  ; // DTG - Предварительный делитель частоты

  MDR_TIMER2->BRKETR_CNTRL = 
  ( 0 << 4 ) | // ETR_FILTER - Цифровой фильтр на входе ETR ( см. техническое описание )
  ( 0 << 2 ) | // ETRPSC - Асинхронный предделитель внешней частоты ( 0 - без деления, 1 - на 2, 2 - на 4, 3 - на 8 )
  ( 0 << 1 ) | // ETR_INV - Инверсия входа ETR ( 0 - без инверсии, 1 - инверсия )
  ( 0 << 0 ) ; // BRK_INV - Инверсия входа BRK ( 0 - без инверсии, 1 - инверсия )
  
  MDR_TIMER2->STATUS =
  ( 0 << 0 ) | // Флаг разрешения прерывания по событию CNT==0 ( 0 - нет прерывания, 1 - есть прерывание )
  ( 0 << 1 ) | // Флаг разрешения прерывания по событию CNT==ARR ( 0 - нет прерывания, 1 - есть прерывание )
  ( 0 << 2 )          // Флаг разрешения прерывания по переднему фронту на входе ETR ( 0 - нетапрерывания, 1 - есть прерывание )
  |( 0 << 3 )          // Флаг разрешения прерывания по заднему фронту на входе ETR ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 4 )          // Флаг разрешения прерывания по тригерированному по PCLK состоянию входа BRK ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 5 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 1-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 6 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 2-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 7 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 3-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 8 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 4-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 9 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 1-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 10 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 2-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 11 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 3-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 12 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 4-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 13 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 1-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 14 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 2-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 15 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 3-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 16 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 4-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  ;

  MDR_TIMER2->IE =
  ( 0 << 0 )          // Флаг разрешения прерывания по событию CNT==0 ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 1 )          // Флаг разрешения прерывания по событию CNT==ARR ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 2 )          // Флаг разрешения прерывания по переднему фронту на входе ETR ( 0 - нетапрерывания, 1 - есть прерывание )
  |( 0 << 3 )          // Флаг разрешения прерывания по заднему фронту на входе ETR ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 4 )          // Флаг разрешения прерывания по тригерированному по PCLK состоянию входа BRK ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 5 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 1-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 1 << 6 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 2-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 7 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 3-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 8 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP 4-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 9 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 1-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 10 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 2-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 11 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 3-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 12 )          // Флаг разрешения прерывания по событию переднего фронта на выходе REF 4-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 13 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 1-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 14 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 2-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 15 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 3-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  |( 0 << 16 )          // Флаг разрешения прерывания по событию переднего фронта на выходе CAP1 4-го канала таймера ( 0 - нет прерывания, 1 - есть прерывание )
  ;
  
  MDR_TIMER2->DMA_RE =
  ( 0 << 16 ) | // СH4_CAP1_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе CAP1 канала 4 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 15 ) | // CH3_CAP1_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе CAP1 канала 3 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 14 ) | // CH2_CAP1_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе CAP1 канала 2 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 13 ) | // CH1_CAP1_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе CAP1 канала 1 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 12 ) | // CH4_REF_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе REF канала 4 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 11 ) | // CH4_REF_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе REF канала 4 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 10 ) | // CH4_REF_EVENT_RE - Флаг разрешения запроса DMA по событию переднего фронта на выходе REF канала 4 таймера ( 0 - нет запроса DMA, 1 - есть запрос DMA )
  ( 0 << 9 )  | 
  ( 0 << 8 )  |
  ( 0 << 7 )  |
  ( 0 << 6 )  |
  ( 0 << 5 )  |
  ( 0 << 4 )  |
  ( 0 << 3 )  |
  ( 0 << 2 )  |
  ( 0 << 1 )  |
  ( 0 << 0 )  ;

}
